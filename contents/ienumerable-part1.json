{"Title":"IEnumerables and collections, part 1","Content":"![IEnumerable inheritance map](contents/files/ienumerable/collection.svg)\r\n\r\n## What is IEnumerable\r\n\r\nImagine you just have some similar items - lego blocks, beads, pencils, or whatever. You didn't give number to them, so they don't have index, but you can **take one by one** (in your head - because it cannot be changed!).\r\n\r\n* It has order internally, but it doesn't expose it.\r\n* The value never changed (immutable). Any LINQ methods will return **new value**.\r\n* They randomly exist on memory. Not one after the other.\r\n\r\n### Why `Count()` is not recommended\r\n\r\n<s>[STOP THE `Count()`!](https://twitter.com/realdonaldtrump/status/1324353932022480896)</s>\r\n\r\nIf the types is IEnumerable, you cannot avoid using `Count()` **method**. But if the type is `ICollection<T>` or its implementation, you can use `Count` **property**. And here is why:\r\n\r\nImagine you have some items like blocks or coins. You don't know  how much is it at a glance, so you count them one by one. this is what `Count()` method does. On the other hand, collection already counted them and remembrs how many items they have. So it's property. If someone already checked how many is it (and you trust the number), you don't need to count by yourself.\r\n\r\n## Immutability\r\n\r\nImmutablity prevents from mistake or unintended editing behaviour.\r\n\r\n* `IEnumerable<T>` are **immutable**.\r\n  * Calling method with LINQ (`System.Linq`) will return new `IEnumerable<T>` instead of changing original one.\r\n* `ICollection<T>` is **mutable**.\r\n  * `IReadOnlyCollection<T>` is **not really immutable**. It just wraps its aggregation. If you want true immutablity, use `ImmtuableList<T>`\r\n\r\n### `IReadOnlyCollection<T>`\r\n\r\n`IReadOnlyCollectoin<T>` just contains mutable collection inside. This is useful when **expose collection** outside class.\r\n\r\n```csharp\r\npublic List<string> Names { get; }\r\n```\r\n\r\nThe *get-only* means in here *you cannot assign new value*. You cannot assign new value, but you still can call the method like `Add()`. This is not intended - it should be mutable only inside class.\r\n\r\n```csharp\r\n//you can't do this\r\nclassName.Names = new List<string>();\r\n//you CAN do this\r\nclassName.Names.Add(\"John\");\r\n```\r\n\r\nThat's why .NET guideline say **do not expose List public, use ReadOnly... instead.**. But is it really immutable? No. **You can edit the target list**.\r\n\r\n```csharp\r\nList<string> languages = new(){ \"C#\", \"F#\" };\r\nReadOnlyCollection<string> readonlyLanguages = new(languages);\r\nlanguages.Add(\"VB.NET\");\r\n//now readonlyLanguages returns : ReadOnlyCollection<string>(4) { \"C#\", \"F#\", \"VB.NET\" }\r\n```\r\n\r\n### What `ImmutableList<T>` (or any `Immutable...<T>`) does\r\n\r\nIf you have already used F#, you can understand easier the `ImmutableList<T>`. You initialize them by calling empty and adding - in this way, they always return new value - like `IEnumerable<T>`, it's truly immutable.\r\n\r\nAlso `Immutable...<T>` is **thread safe**.\r\n\r\n> `System.Collections.Immtable` is available via NuGet package manager.\r\n\r\n## IEnumerator&lt;T&gt;\r\n\r\n`IEnumerable<T>` and `IEnumerator<T>` don't have any inherit relationship. `IEnumerable<T>` creates `IEnumerator<T>` by calling `GetEnumerator()` method.\r\n\r\n`IEnumerator<T>` is interface for iterator. [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) is design pattern for traversing elements inside container.\r\n\r\nEach class that inherited from `IEnumerator<T>` also implements `GetEnumerator()`, so Enumerator has own implementation - for example, `List<T>.Enumerator`. `foreach()` loop calls `GetEnumerator()` to iterate.\r\n\r\nImplementation of Enumerator is `struct`, because iterator is small and simple. Using struct for small object [improves performance](https://softwareengineering.stackexchange.com/questions/411302/why-listt-enumerator-is-struct).\r\n\r\n> **Do not edit the aggregation while iterating**, include `foreach()` loop. If collection is changed after getting `IEnumerator<T>`, `IEnumerator<T>.MoveNext()` will throw exception.\r\n\r\n## IGroupping and IOrderedEnumerable\r\n\r\nThis is common when `System.Linq` is used. `IGroupping` is result of `IEnumerable<T>.GroupBy()` and `IOrderedEnumerable` is result of `IEnumerable<T>.OrderedBy()` (or `IEnumerable<T>.OrderByDescending()`)\r\n\r\n`IOrderedEnumerable<T>` assures that they are ordered by some criteria - not much difference from `IEnumerable<T>` (But may used for further custom implemenation).\r\n\r\n## Collection\r\n\r\nUnlike `IEnumerable<T>`, now it's mutable - can add, remove, or get how much is it without counting. Still they **don't have index**, so it works with concept of **set** (which really implements `ICollection<T>`)\r\n\r\n`IReadOnlyCollection` **does not implement add/delete**. Instead, it implements only `Count()`. This is used by some read-only collections that doesn't need to implement adding and deleting.\r\n\r\nAnother interesting implemenation is `Stack` and `Queue` - they aren't readonly, but the naming is bit different - it doesn't \"add/delete\", but \"push/pop/queue/dequeue\". So they are implemented own editing behaviours with their own name.\r\n\r\n[Next...](Blog/posts/ienumerable-part2.html)\r\n","CreationDate":"2021-01-01T13:09:26.4607315+02:00","ModificationDate":"2021-01-02T00:11:22.6426462+02:00","Tags":["C#"]}