{"Title":"C# 9 Features - Why, and when to use","Content":"\r\nhttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\r\n\r\n## Record Types\r\n\r\nIf you have ever tried Kotlin, you've seen the `data` class. And the F# already [had record type](https://fsharpforfunandprofit.com/posts/records/). (Thinking immutability of functional language, it's not surprise) And it's finally on C#. But, why? Why they're not happy with just `class` and `readonly` fields?\r\n\r\nThe point is: **the whole class is `readonly`**. It's better for concurrency, when data is shared.\r\n\r\nThis is most useful when you design **models**, including **database classes**. It can represent real database (Think of the Entity Framework) or DTO (Domain Transfer object) - but when it's implemented in DTO, consider of immutability (if it's changed frequently may not fit - `initonly` may better choice dppending on the situation). Not only anemic class (class with only data types), but you can define some methods, so non-anemic data goes along too. EF Core can have [inheritance](https://docs.microsoft.com/en-us/ef/core/modeling/inheritance)? No problem. Record supports inheritance too.\r\n\r\nIt works well with **(de)serialization**, such as JSON serializer. (But please be careful with the case-sensitivity of the keys!)\r\n\r\n```csharp\r\n//the record\r\nrecord OperatingSystem(string Name, string Version);\r\n```\r\n\r\n```csharp\r\nusing System;\r\nusing System.Text.Json;\r\n\r\nOperatingSystem os = JsonSerializer.Deserialize<OperatingSystem>(\"{\\\"Name\\\":\\\"Windows\\\", \\\"Version\\\":\\\"8.1\\\"}\");\r\nConsole.WriteLine($\"{os.Name} {os.Version}\"); //Windows 8.1\r\n\r\nOperatingSystem anotherOS = os with { Version = \"XP\" }; // NOTE: it does *shallow copy*\r\nstring serializedOS = JsonSerializer.Serialize(anotherOS);\r\nConsole.WriteLine(serializedOS); //{\"Name\":\"Windows\",\"Version\":\"XP\"}\r\n```\r\n\r\n> According to .NET Conf 2020, anonymous record is not supported, though can come with C# 10.\r\n\r\n## Init Only\r\n\r\nIf you want to make property readonly (so only can set inside constructor), you can put only `get` (getter) without `set` (setter). This way you can initialize values with *inside constructor*.\r\n\r\nThis `init` is different from the readonly (get only) in two ways:\r\n\r\n1. You can initialize **when creating**.\r\n2. Constructor of **inherited class** can initialize it.\r\n\r\nThis is the example of first feature. First, you define a class like this:\r\n\r\n```csharp\r\n    class Asdf\r\n    {\r\n        public string S { get; }\r\n        public int X { get; init; }\r\n    }\r\n```\r\n\r\nAnd try this:\r\n\r\n```csharp\r\n    new Asdf {\r\n        X = 1, //OK\r\n        S=\"Test\" //Error\r\n    };\r\n```\r\n\r\nYou can make **properties readonly without constructor arguments**. Especially if there are many properties, the definition and usage can be nasty. (There are also something like `new X(a:1, b:3)`, still you must struggle with some optional or non-optional parameters, constructor defintion is tiring and you must write more boring usage documnetation...) - or giving all of them just setter, but if not initialization only, unintended annoying value change can occur. And that's why init only is good. Consider:\r\n\r\n```csharp\r\n//If...\r\nclass Product\r\n{\r\n    public string Name { get; }\r\n    public float Price { get; }\r\n}\r\n//Then...\r\nProduct product = new Product\r\n{\r\n    Name = \"T-Shirt\",\r\n    Price = 12.30f\r\n};\r\n//Won't work.\r\n//--------------------\r\n//But if...\r\nclass Product\r\n{\r\n    public string Name { get; set; }\r\n    public float Price { get; set; }\r\n}\r\n//Then...\r\nProduct product = new Product\r\n{\r\n    Name = \"T-Shirt\",\r\n    Price = 12.30f\r\n};\r\nproduct.Name = \"Ice Cream\";\r\n//You can change Product name, which *isn't expected*\r\n//-----------\r\n\r\n//So you can solve both problem with it.\r\nclass Product\r\n{\r\n    public string Name { get; init; }\r\n    public float Price { get; init; }\r\n}\r\n//Now you can do this\r\nProduct product = new Product\r\n{\r\n    Name = \"T-Shirt\", //all of them are optional\r\n    Price = 12.30f\r\n};\r\n//But cannot do this\r\nproduct.Name = \"Ice Cream\";\r\n//------------\r\n//Also can set default value from wherever\r\nclass Product\r\n{\r\n    public string Name { get; init; } = \"Chocolate\";\r\n    public float Price { get; init; } = 5.99f;\r\n}\r\n```\r\n\r\nYou can read more clear descriptions from [here](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/init).\r\n\r\n> As you see in the link above, there are some features that proposed but not implemented, such as `initonly` or `init set`.\r\n\r\nIf you want to make immutable part of the properties after initializing, `init` is for you. Now we can control easily what can be changed or what cannot be changed.\r\n\r\n## Top-level statements\r\n\r\n![It's just main method with some sweets (sugars)](contents/files/csharp9/hello_world.jpg)\r\n\r\nTop-level statements **is all about just defining inside `Main` method** - `string[] args` are automatically defined and return value should be `int` (or nothing, just `return;`).\r\n\r\nMicrosoft Docs tells about some benefits of the top-level statements like this:\r\n\r\n1. Teaching material. Hello world in 1-2 line lowers threshold.\r\n2. Script experience.\r\n3. **Azure Functions** is good usage of the top-level statements.\r\n4. **Scope Complexity**.\r\n\r\n> Note: Know the limitations of this. C# is not like JavaScript or Python - it's still class-based langauge.\r\n>\r\n> 1. You can define **only one file (main) per project** - if something is top-level statement, it becomes main file. Outside of them you still need to define a class/struct/record.\r\n> 2. The file that contains top-level statement **cannot contain any class/struct/record definition**.\r\n\r\n## Pattern matching enhancements\r\n\r\n### Pattern matching, why?\r\nYou can check some statements with `if-else` statements, but it's nasty. Besides, `if` compares only **once at a time**, so it's [usually slower than `switch`](https://twitter.com/MadsTorgersen/status/1326230723649392640?s=20).\r\n\r\n```mermaid\r\nflowchart TB\r\n  subgraph Switch statement\r\n    N[Milk]\r\n    N-->X[Water]\r\n    N-->Y[Juice]\r\n    N-->Z[Milk]\r\n    end\r\n  subgraph If statement\r\n    subgraph 1\r\n      A[Milk]-->Water\r\n    end\r\n    subgraph 2\r\n      B[Milk]-->Juice\r\n    end\r\n  subgraph 3\r\n      C[Milk]-->Milk\r\n    end\r\n    1-->2\r\n    2-->3\r\n  end\r\n```\r\n\r\nStill it's usually not so big optimization, so it looks like matter of taste, if small performance doesn't matter. But reading codes in a glance without \"if\" text is more clear, so, now there are two important reasons to use switch(pattern matching) in many ways.\r\n\r\nThe imporved pattern matching is [supported from C# 8.0](https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/may/csharp-8-0-pattern-matching-in-csharp-8-0). Now C# 9 supports:\r\n\r\n* `and`, `or` and `not`. (Note that `when` match was already existed before C# 9.)\r\n* \\>= and =< operators.\r\n* Nested pattern match (for example, inside `()`) support (\"Parenthesized\" pattern)\r\n\r\nStill there are some taste matters left, [for example](https://twitter.com/RicoSuter/status/1326322704774000641?s=20):\r\n\r\n![x is string and not \"\"](contents/files/csharp9/brain.jpg)\r\n\r\nIt's not familiar for old C# developers, but it's worth to use the advanced pattern matching. (Especially if you want to be familiar with functional programming)\r\n\r\n## Fit and Finish\r\n\r\nThis is just a **syntax sugar**. And why it's good is you can write less code.\r\n\r\n```csharp\r\nProduct product { get; set; }\r\n//...\r\nproduct = new() { Name = \"Toy\", Price = 11.2f };\r\nOperatingSystem os = new(\"Windows\", \"Vista\");\r\n```\r\n\r\nBesides, you have less concern to the typo.\r\n\r\n```csharp\r\nnew HttpRequestMessage(new(\"POST\"), \"https://localhost\"); //HTTP Method, Uri(string)\r\nnew Regex(\"/[0-9]/\", new(), new(2000)); //Regex Options, Timespan\r\n```\r\n\r\n## Code generator (A.k.a. Source generator)\r\n\r\nSource generator generates source from code. Benefits of source generator is described in [here](https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/). The link also describes what it is and how to use.\r\n\r\n1. The **startup/runtime performance** is better (Wiring up, by *saving settings*)  \r\n   Runtime-costs (*reflection*) performance will move to compile-time.  \r\n2. When **compiler is called multiple times**, source generator is faster.  \r\n   When inspecting data for compilation, this can occur.\r\n3. \"**Stringly Typed**\" (PREDEFINE TYPES!)  \r\n   For example, ASP.NET Core Routing: For example, `{name:int}` should check if route value is `int`.\r\n\r\n> Note: Even if code generator can replace some of reflection to AOT-compiled code, it's not for replacing reflection - reflection is still powerful tool so you may not need to change it.\r\n","CreationDate":"2020-09-06T17:00:34.3531027+03:00","ModificationDate":"2020-11-13T09:20:50.6366821+02:00","Tags":["C#"]}