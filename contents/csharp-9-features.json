{"Title":"C# 9 Features - Why, and when to use","Content":"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\n\n## Record Types\n\nIf you have ever tried Kotlin, you've seen the `data` class. And the F# already [had record type](https://fsharpforfunandprofit.com/posts/records/). (Thinking immutability of functional language, it's not surprise) And it's finally on C#. But, why? Why they're not happy with just `class` and `readonly` fields?\n\nThe point is: **the whole class is `readonly`**. It's better for concurrency, when data is shared.\n\nThis is most useful when you design **models**, including **database classes**. It can represent real database (Think of the Entity Framework) or DTO (Domain Transfer object). Not only anemic class (class with only data types), but you can define some methods, so non-anemic data goes along too. EF Core can have [inheritance](https://docs.microsoft.com/en-us/ef/core/modeling/inheritance)? No problem. Record supports inheritance too.\n\nIt works well with **(de)serialization**, such as JSON serializer. (But please be careful with the case-sensitivity of the keys!)\n\n```csharp\n//the record\nrecord OperatingSystem(string Name, string Version);\n```\n\n```csharp\nusing System;\nusing System.Text.Json;\n\nOperatingSystem os = JsonSerializer.Deserialize<OperatingSystem>(\"{\\\"Name\\\":\\\"Windows\\\", \\\"Version\\\":\\\"8.1\\\"}\");\nConsole.WriteLine($\"{os.Name} {os.Version}\"); //Windows 8.1\n\nOperatingSystem anotherOS = os with { Version = \"XP\" }; // NOTE: it does *shallow copy*\nstring serializedOS = JsonSerializer.Serialize(anotherOS);\nConsole.WriteLine(serializedOS); //{\"Name\":\"Windows\",\"Version\":\"XP\"}\n```\n\n> According to .NET Conf 2020, anonymous record is not supported, though can come with C# 10.\n\n## Init Only\n\nIf you want to make property readonly (so only can set inside constructor), you can put only `get` (getter) without `set` (setter). This way you can initialize values with *inside constructor*.\n\nThis `init` is different from the readonly (get only) in two ways:\n\n1. You can initialize **when creating**.\n2. Constructor of **inherited class** can initialize it.\n\nThis is the example of first feature. First, you define a class like this:\n\n```csharp\n    class Asdf\n    {\n        public string S { get; }\n        public int X { get; init; }\n    }\n```\n\nAnd try this:\n\n```csharp\n    new Asdf {\n        X = 1, //OK\n        S=\"Test\" //Error\n    };\n```\n\nYou can make **properties readonly without constructor arguments**. Especially if there are many properties, the definition and usage can be nasty. (There are also something like `new X(a:1, b:3)`, still you must struggle with some optional or non-optional parameters, constructor defintion is tiring and you must write more boring usage documnetation...) - or giving all of them just setter, but if not initialization only, unintended annoying value change can occur. And that's why init only is good.\n\nThis is also **very useful for data type** like record above, and you can use both - because the data should not changed after initialization, but still initialization should be allowed. It works very well with database type, DTO, serialization (like configuration, REST API or whatever).\n\n```csharp\n//If...\nclass Product\n{\n    public string Name { get; }\n    public float Price { get; }\n}\n//Then...\nProduct product = new Product\n{\n    Name = \"T-Shirt\",\n    Price = 12.30f\n};\n//Won't work.\n//--------------------\n//But if...\nclass Product\n{\n    public string Name { get; set; }\n    public float Price { get; set; }\n}\n//Then...\nProduct product = new Product\n{\n    Name = \"T-Shirt\",\n    Price = 12.30f\n};\nproduct.Name = \"Ice Cream\";\n//You can change Product name, which *isn't expected*\n//-----------\n\n//So you can solve both problem with it.\nclass Product\n{\n    public string Name { get; init; }\n    public float Price { get; init; }\n}\n//Now you can do this\nProduct product = new Product\n{\n    Name = \"T-Shirt\", //all of them are optional\n    Price = 12.30f\n};\n//But cannot do this\nproduct.Name = \"Ice Cream\";\n//------------\n//Also can set default value from wherever\nclass Product\n{\n    public string Name { get; init; } = \"Chocolate\";\n    public float Price { get; init; } = 5.99f;\n}\n```\n\nYou can read more clear descriptions from [here](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/init).\n\n> As you see in the link above, there are some features that proposed but not implemented, such as `initonly` or `init set`.\n\nIf you want to make immutable part of the properties after initializing, `init` is for you. Now we can control easily what can be changed or what cannot be changed.\n\n## Top-level statements\n\n![It's just main method with some sweets (sugars)](contents/files/csharp9/hello_world.jpg)\n\nTop-level statements **is all about just defining inside `Main` method** - `string[] args` are automatically defined and return value should be `int` (or nothing, just `return;`).\n\nMicrosoft Docs tells about some benefits of the top-level statements like this:\n\n1. Teaching material. Hello world in 1-2 line lowers threshold.\n2. Script experience.\n3. **Azure Functions** is good usage of the top-level statements.\n4. **Scope Complexity**.\n\n> Note: Know the limitations of this. C# is not like JavaScript or Python - it's still class-based langauge.\n>\n> 1. You can define **only one file (main) per project** - if something is top-level statement, it becomes main file. Outside of them you still need to define a class/struct/record.\n> 2. The file that contains top-level statement **cannot contain any class/struct/record definition**.\n\n## Pattern matching enhancements\n\n### Pattern matching, why?\nYou can check some statements with `if-else` statements, but it's nasty. Besides, `if` compares only **once at a time**, so it's [usually slower than `switch`](https://twitter.com/MadsTorgersen/status/1326230723649392640?s=20).\n\n```mermaid\nflowchart TB\ntitle[\"IF STATEMENT\"]\ntitle-.-1\n    subgraph 1\n      A[Milk]-->Water\n    end\n    subgraph 2\n      B[Milk]-->Juice\n    end\n  subgraph 3\n      C[Milk]-->Milk\n    end\n    1-->2\n    2-->3\n    title2[\"SWITCH STATEMENT\"]\n    title2-.-N\n    N[Milk]\n    N-->X[Water]\n    N-->Y[Juice]\n    N-->Z[Milk]\n```\n\nStill it's usually not so big optimization, so it looks like matter of taste, if small performance optimization doesn't matter. But reading codes in a glance without \"if\" text is more clear, so, now there are two important reasons to use switch(pattern matching) in many ways.\n\nThe imporved pattern matching is [supported from C# 8.0](https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/may/csharp-8-0-pattern-matching-in-csharp-8-0). Now C# 9 supports:\n\n* `and`, `or` and `not`. (Note that `when` match was already existed before C# 9.)\n* \\>= and =< operators.\n* Nested pattern match (for example, inside `()`) support (\"Parenthesized\" pattern)\n\nStill the extended feature is matter of taste. Some people love it, while some other people hate it. (Someone said it's \"Syntax Marmite\" - it's loved and hated by people, like a pineapple pizza.)\n\n![x is string and not \"\"](contents/files/csharp9/brain.jpg)\n\nIt's not familiar for old C# developers, but it's worth to use the advanced pattern matching. (Especially if you want to be familiar with functional programming)\n\n## Fit and Finish\n\nThis is just a **syntax sugar**. And why it's good is you can write less code.\n\n```csharp\nProduct product { get; set; }\n//...\nproduct = new() { Name = \"Toy\", Price = 11.2f };\nOperatingSystem os = new(\"Windows\", \"Vista\");\n```\n\nBesides, you have less concern to the typo.\n\n```csharp\nnew HttpRequestMessage(new(\"POST\"), \"https://localhost\"); //HTTP Method, Uri(string)\nnew Regex(\"/[0-9]/\", new(), new(2000)); //Regex Options, Timespan\n```\n\n## Code generator (A.k.a. Source generator)\n\nSource generator generates source from code. Benefits of source generator is described in [here](https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/). The link also describes what it is and how to use.\n\n1. The **startup/runtime performance** is better (Wiring up, by *saving settings*)  \n   Runtime-costs (*reflection*) performance will move to compile-time.  \n2. When **compiler is called multiple times**, source generator is faster.  \n   When inspecting data for compilation, this can occur.\n3. \"**Stringly Typed**\" (PREDEFINE TYPES!)  \n   For example, ASP.NET Core Routing: For example, `{name:int}` should check if route value is `int`.\n\n> Note: Even if code generator can replace some of reflection to AOT-compiled code, it's not for replacing reflection - reflection is still powerful tool so you may not need to change it.\n","CreationDate":"2020-09-06T17:00:34.3531027+03:00","ModificationDate":"2020-11-22T15:20:40.0364124+02:00","Tags":["C#"]}