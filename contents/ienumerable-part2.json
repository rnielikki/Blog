{"Title":"IEnumerables and collections, part 2","Content":"![IEnumerable inheritance map](contents/files/ienumerable/collection.svg)\r\n\r\n[Before...](posts/ienumerable-part1)\r\n\r\n## List vs Set vs LinkedList vs Array\r\n\r\n### Array\r\n\r\nArray means the **data is one after the other** in the memory.\r\n\r\nArray is used (over `List<T>`) when:\r\n\r\n* Size is rather fixed (no need to `Add()`/`Remove()`)\r\n* Editing specific index is preferred than removing/adding\r\n\r\n`Array.Resize()` can resize the array, but it's annoying to call every time. That's why we have `List<T>`.\r\n\r\n> When resize the array, the system just allocate the array again. Like moving house, if the data don't fit, they move to larger place in memory.\r\n\r\n### List\r\n\r\nWhen? **Common Append/Remove**\r\n\r\n`List<T>` is most common type to add, remove, or edit. It fits in many cases, so go with it, if it's not special case, or it causes massive performance down (like editing so many middle of elements or searching).\r\n\r\n`List<T>` works like **dynamic `Array`** (Or **`Vector`**, for C++ or Rust folks). Unlike array, it **changes size by itself**. And this is why `List<T>` also have indexes and can get data with their index. Of course data is allocated on one after another, in physical memory.\r\n\r\n### LinkedList\r\n\r\nWhen? **Edit middle of element(s) many times**\r\n\r\n![Linked List](contents/files/ienumerable/linkedlist.png)\r\n\r\n`LinkedList<T>` is not used in many cases, though. The usage is very different from `List<T>`. The special case can be found, for example, [Advent of Code 2020 Day 23](https://adventofcode.com/2020/day/23).\r\n\r\n`LinkedList<T>` consists of **two-way connected nodes** called `LinkedListNode<T>`. If the element is on the first, `Previous` value is `null`. If it's on the last line, `Next` value is `null`.\r\n\r\n> `LinkedList<T>` event **doesn't implement `IList<T>`**.\r\n\r\n### Set\r\n\r\nWhen? \"**Searching**\"\r\n\r\nUnlike `List<T>`, `ISet<T>` can contain same element only once. It uses `object.Equals()` to compare. Searching with Set is much faster - especailly the collection contains so many elements.\r\n\r\n`HashSet<T>`, which is most commonly used set, doesn't care of order, but there are also `SortedSet<T>`.\r\n\r\nIf you want to change how to compare them, you can override `object.Equals()`. In the `HashSet<T>` case, `GetHashCode()` determines if it's unique.\r\n\r\n```mermaid\r\ngraph TD\r\n  A[\"Set<Drink>\"]\r\n  A-->Water\r\n  A-->Milk\r\n  A-->Juice\r\n```\r\n\r\n### Dictionary\r\n\r\n`Dictionary<K,V>` is key-value pair. Look at the dictionary - you search a word, and then you read definition. The word is key, the definition is value. The key is unique and searching value with key is as fast as `Set`. It means that the **dictionary key works like Set**.\r\n\r\nYou can find the concept of dictionary as \"Map\" in many languages.\r\n\r\n### Stack, Queue\r\n\r\nStack and Queue is well-known type. Stack is LIFO (Last-In-First-Out) and Queue is FIFO (First-In-First-Out). For example, undoing some actions can use \"stack\", because recent action (Last-in) should be undo first(First-out). Message \"queueing\" is very common architecture - when messages are come from multiple places, queue put messages 'on the line', and messages wait in there.\r\n\r\n> Even the queue is useful for message queueing, `Queue<T>` (and `Stack<T>`) is not thread-safe. For thread-safety, see next.\r\n\r\n## A bit story for parallel programming\r\n\r\nYou can get `IndexOutOfRangeException` or `AggregateException` from a collection - Even the element is not enough for throwing \"out of range\", and the size change from adding is expected from collection.\r\n\r\nIt's somewhat like everyone try to edit the same cell - Imagine that two tasks try to add a element to an list. Both checks list size and the number is 10 *(10/10)*. Both think the number should be allocated to 11 *(10/11)* - in fact, it's 12, because two task will add a element. And one of the tasks already added to the list *(11/11)*. The other one fails - because allocated is 11 and other one already filled it *(12/11)*. This causes `IndexOutOfRangeException`.\r\n\r\nThe list and set is not thread-safe. So `Systme.Collection.Concurrent` is ready for them. It contains:\r\n\r\n* `ConcurrentBag<T>`\r\n* `ConcurrentStack<T>`\r\n* `ConcurrentQueue<T>`\r\n* `ConcurrentDictionary<K,V>`\r\n\r\nYou can implement the concurrency by yourself, but `ConcurrentDictionary` is faster than locking every time by your own.\r\n\r\n> **`ConcurrentSet<T>` currently [doesn't exist](https://github.com/dotnet/runtime/issues/39919)**. If you want one, you must implement it.\r\n","CreationDate":"2021-01-01T17:12:05.1025414+02:00","ModificationDate":"2021-01-02T00:18:33.0435921+02:00","Tags":["C#"]}