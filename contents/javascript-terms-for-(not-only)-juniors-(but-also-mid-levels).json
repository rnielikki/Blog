{"Title":"Javascript terms for (not only) juniors (but also mid-levels)","Content":"From [this tweet](https://twitter.com/cat__logic/status/1285921212170940416?s=20).\n\n## let vs var vs const (+ variable scopes)\n\n* Level: Basic\n\n* Related MDN docs: [let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let), [var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var), [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)\n\n![var is function scope, const and let are variable scope. const is immutable, while var and let are.](files/js_terms/1_scope.png)\n\n## bind vs call vs apply\n\n* Level: Hard\n\n* Related MDN docs: [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind), [call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call), [apply](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\nIf you don't know what they are: they can define what is `this` for the functions.\n\nThe usage of bind, call, apply looks almost same - bind and call are same, and apply uses array instead of parameters. It means that call(this, ...[a, b]) and bind(this, [a, b]) results same.\n\n![var is function scope, const and let are variable scope. const is immutable, while var and let are.](files/js_terms/2_bind_call_apply.png)\n\n> Note: As you see, **`bind()` creates new method** because `bind()` returns new function! `myFunction.bind()` is not `myFunction` anymore! This affects e.g. when removing specific event from `EventListener`.\n\n## Hoisting\n\n* Level: Medium\n\n* Related MDN docs: [Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)\n\nIf you have tried C or C++, you know they don't have this one. Or you may forgot it, when JavaScript is too familiar to you.\n\n![Hoisting moves automatically all functions first. In result, on the code, a function is called first and then can defined later in the code.](files/js_terms/3_hoisting.png)\n\nThis process is not visible to your code, but internally happens.\n\n## Closure\n\n* Level: Hard\n* Related MDN docs: [Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)\n\nIf you learned C# and saw what is `delegate`, it's easier to understand what closure is. It points another function (and works also similar to 'method group' in C#)\n\n![function can return function. then the returned function can be called by calling twice.](files/js_terms/4_closure.png)\n\nOne of the difference from C# `delegate` is invoking - JavaScript provides more flexible and easy syntax to invoke them. The example in the MDN page is interesting:\n\n```javascript\nfunction makeLabel(label){\n    return function(value){ return label + \": \"+ value; }\n}\nvar nameLabelMaker = makeLabel(\"Name\");\nvar nameLabelOne = nameLabelMaker(\"John\"); //Name: John\nvar nameLabelTwo = nameLabelMaker(\"Daisy\"); //Name: Daisy\n```\n\nIt can define what kind should be produced first (Name), and use the produced function (John, Daisy).\n\n## == vs ===\n\n* Level: Basic\n\n* Related MDN docs: [Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)\n\n== is loose equality, and === means strict equality.\n\nWell-known example is number and string comparison, `42 == \"42\"` but `42 !== \"42\"`. But when it extends to others, such as empty array or object, it becomes more complicated.\n\nAbout the detail, which ones are same with loose equality, see more on [the MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness) - it's more complicated.\n\nBut you don't need to remember everything, which ones are same with loose equality, because **strict equality (===) is used** in practice to avoid confusion (and should be).\n\n## Falsy / Truthy variables\n\n* Level: Basic\n\n* Related MDN docs: [Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy), [Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)\n\nSome syntaxes requires `boolean` value, such as `if()` or `while()`. Well-known case of truthy and falsy values are \"0 is false\" and \"1 is true\" (like C or C++).\n\nBut JavaScript is so non-strict, so any other things than real `true`, `false`, 0 or 1 can go into `if()` to check if it's true.\n\nThe falsy values are: `null`, `undefined`, `0`, `\"\"` (empty string), `NaN` - others are truthy.\n\n> Note: \"0\" (string), empty arrays and empty objects are truthy, but empty array and `\"0\" == false` and `[] == false`. **Truthy value does not always mean that the value is non-strictly equal to true**.\n\n## IIFE (Immediately Invoked Function Expression)\n\n* Level: Basic\n* Related MDN docs: [IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)\n\nIt's easy to understand, but may not very important for beginners.\n\nIt looks like this.\n\n```javascript\n(function(){\n})();\n```\n\nWith IIFE, you can add parameter to it like this.\n\n```javascript\n(function(x){\n    console.log(x);\n})(\"hello, world!\");\n```\n\nAs the name says, this IIFE function fires **immediately** without need to assign the function.\n\nIIFE wraps all the variables inside. Since IIFE directly contains anonymous function that executes immediatly, there are no concern of name duplication. It also wraps scopes inside and prevents functions and variables from being global.\n\n## functions vs => (Arrow function expression)\n\n* Level: Medium\n\n* Related MDN docs: [Arrow function expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n\nIt changes this function\n\n```javascript\nfunction( ... ) { ... }\n```\n\ninto\n\n```javascript\n( ... ) =>  ...\n```\n\nIs it syntax sugar? If they're identical, they are, but there are one significant difference - it's `this`. This will be explained later.\n\n## Anonymous functions\n\nLevel: Basic\n\nSomething that looks like this are anonymous functions:\n\n```javascript\nfunction(){\n    //something\n}\n```\n\nWhich means literally \"anonymous\", without name.\n\nThe anonymous functions can be assigned as variable, or can be placed in the place of callback.\n\n```javascript\nvar x = function(){\n    // something\n}\nsetTimeout(function(){\n    //something\n}, 1000);\n```\n\n> Note: Don't expect hoisting with anonymous functions that registered to variable.\n>\n>```javascript\n> x(); //Error! Because x is variable that contains anonymous function.\n> var x = function(){ console.log(\"Hello world!\"); }\n>```\n\n## forEach() vs map()\n\nLevel: Basic-Medium\n\nBoth applies each values to the callback function. Simply, the difference is return value.\n\n`forEach()` just \"does the work\", while `map()` actually \"returns\" the results.\n\n## null vs undefined\n\nLevel: Hard\n\n```javascript\ntypeof(null) //object\ntypeof(undefined) //undefined\n```\n\n`null` is **empty object**, whereas `undefined` is **not definied**.\n\nUndefined is **a type** for any unassigned value. When something is unassigned but used, using default value or throwing error is expected. JavaScript uses dynamic type, even if the type exists (`typeof` shows the type). So JavaScript cannot set the value depending on the type. So that's why `undefined` is default when value is not defined or unassigned.\n\nStill `undefined` is weird thing on JavaScript - when value is not defined or unassigned, throwing error is better solution for preventing weird errors.\n\n## this\n\n* Level: Hard\n\n* Related MDN docs: [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)\n\nIt's one of the greatest question. `this` on JavaScript is not only hard but also confusing.\n\nbefore starting, you must understand: globalThis and what the `'use strict'` does.\n\nWithout strict mode, it returns `globalThis` if `this` is not defined. In strict mode, `globalThis` is returned, only the `this` is accessed directly, outside any function, class, object.\n\n* Non-strict mode: Is there definition about `this`? -> No ->  `globalThis`\n\n* Strict mode: Is there definition about `this`? -> No -> `undefined`\n\n* `this` is \"defined\": inside object / class, defined manually (bind / call / apply), global value (globalThis)\n\n* `this` is \"not defined\": inside function (includes IIFE)\n\nSince this one is complicated (and will need separated article), I recommend to read more from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) if you want to know about more.\n\n### With  Arrow Functions\n\n**Arrow function doesn't care about the custom `this` context**, which means, *`thisObj`* affects nothing to arrow functions via `bind`, `call` and `apply`.\n\n```javascript\nvar arrow = ()=>this;\nvar nonArrow = function(){ return this; };\narrow.call(\"any this\"); //returns globalThis\nnonArrow.call(\"any this\"); //returns string \"any this\"\n```\n\nSame thing can be found when event listener is used - **with arrow function, the value of `this` is consistent**. When the event callback is arrow function, `this` isn't HTML element but the default value. If you want to use class variables with DOM event, arrow function simply can solve the problem.\n\nThe arrow function's `this` means current \"instance\". So it doesn't consider the parent object as `this`.\n\n```javascript\nvar asdf = {\n    x:function(){ return this },\n    y:()=>this\n};\nasdf.x() //returns object asdf\nadsf.y() //returns global this\n```\n\n```javascript\nfunction x(){\n  var a = function(){ console.log(this) }\n  var b = () => console.log(this)\n  a(); //Window\n  b(); //x\n}\nnew x(); //Note: calling x() without new keyword results same value.\n```","CreationDate":"2020-07-27T20:36:18.6115052+03:00","ModificationDate":"2020-07-27T20:36:18.6115052+03:00","Tags":["JavaScript"]}